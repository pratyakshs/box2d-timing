<h1>Timing</h1>
<h2>Introduction</h2>
<p>For the following analysis, we have used no. of iterations = 1500 and no. of reruns = 150.</p>
<h2>Analysis of Loop time vs No. of iterations</h2>
<img src="../plots/g09_lab09_plot01.png" height="45%" />
<p>The average step time almost remains constant. We obtain more accurate data as we take further iterations into account.</p>
<p>The total loop time increases almost linearly. There are some ups and downs in the line graph which indicates that the solver is only invoked when it is needed. In some particular iteration, where more collisions occur (and/or more objects move) take longer time for solver to solve and hence there is some variation in the (almost) linear loop time.</p>
<h2>Observations from graph of Step time, Collision time, Velocity time, Position time vs Iteration values</h2>
<img src="../plots/g09_lab09_plot02.png" height="45%" />
<p>Box2D uses constraint solver for solving constraints. The constraint solver solves all the constraints in the simulation, one at a time. Although single constraint can be solved perfectly, when we solve one constraint, we slightly disrupt other constraints. Therefore to get a good solution, we need to iterate over all constraints a number of times (in the same time step).</p>
<p>This creates a trade-off between speed and accuracy. Using fewer iterations increases performance but accuracy suffers. Likewise, using more iterations decreases performance but improves the quality of your simulation. Since velocity iterations are more than position iterations, this acts as one of the factors in due to which time taken for velocity solving is more than that for position solving.</p>
<h2>Observations from above two graphs</h2>
<p>From graphs 1 and 2 we can note that loop time lies below the average loop time and step time lies below the average time until iteration number is approx. 400. In our simulation on the iterations near 400, suddenly multiple collisions occur (the point when the last falling domino hits the set of balls on the platform) and moving objects also increase. Thereafter, as the iteration value increases all characteristics (vel\_time ,pos\_time ,collision time,loop time)  remain almost constant.</p>
<h2>Observations from Step time average (error bars) vs No. of Iterations graph</h2>
<img src="../plots/g09_lab09_plot03.png" height="45%" />
<p>Note that the above plots represents average step time and y-error bars , the difference between the max and min values is large. Although the values are taken within 150 reruns, there are theses differences due to system processes. As the data is very large, error remains uniform over large values.</p>
<h2>Effect of different types of system load</h2>
<p>a) When memory heavy processes are running, and the process has less available memory to run. The system tries to free some memory by killing other processes. Since processor may still be idle, the running time is not significantly affected. b) When CPU heavy processes are running, the execution time increases significantly. This is because less processor cycles are used towards a particular process.</p>
<p>Observations for 10000 iterations: <br/>Normal (8\% CPU,16\% mem usage) 1.572s <br/> CPU load (97\% CPU,20\% mem usage) 2.208s <br/> RAM load (12\% CPU, 91\% mem usage) 1.625s <br/> CPU and RAM load (92\% CPU, 91\% mem usage) 2.856s</p>
<h2>gettimeofday() vs time</h2>
<p><i>time</i> writes a message to standard output giving timing statistics about this program run. <br/> Real time: the elapsed real time between invocation and termination, <br/> User time: the user CPU time <br/> System time: the system CPU time <br/> The user time tells us how long your program was running on the CPU. The system time tells how long  the program was waiting for the OS to perform the given tasks for it. Real time: This is the actual time difference between starting and ending of program. This can be affected by other running processes. The Unix time command measures the whole program execution time, including the time it takes for the system to load your binary and all its libraries, and the time it takes to clean up everything once your program is finished.</p>
<p>Gettimeofday can only work inside your program, that is after it has been initialized, and before it is terminated.</p>
